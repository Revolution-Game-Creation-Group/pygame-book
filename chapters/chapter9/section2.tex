\section{Οπτική Ένδειξη LASER Hit}

Τι καλά που θα ήταν αν κάθε φορά που μας χτυπάνε οι χαζοί εξωγήινοι να
είχαμε μια οπτική ένδειξη.  Τη δεδομένη στιγμή η μόνη ένδειξη που έχουμε
είναι ένας ήχος (και φυσικά να βλέπουμε την ασπίδα μας να πέφτει). Σε
πολλά shoot-em-up θα παρατηρήσετε ότι το διαστημοπλοιάκι αναβοσβήνει
ή αλλάζει χρώμα όταν δέχεται μια βολή.  Το δικό μας όμως τίποτα. Τι
πρέπει να κάνουμε;

Με λίγη σκέψη καταλήγουμε στο συμπέρασμα ότι
χρειαζόμαστε μια δεύτερη εικόνα για το διαστημόπλοιο μας, με ένα χρώμα
ελαφρώς διαφορετικό. 

Η γενική ιδέα είναι προφανώς ότι από τη στιγμή που θα δεχτούμε μια βολή
θα προβάλλουμε εναλλάξ την κανονική εικόνα του διαστημοπλοίου και την
δεύτερη για κάποιο χρονικό διάστημα. Αλλά υπάρχει πρόβλημα.

\begin{itemize}
\item[-] Πόσο γρήγορα θα γίνεται η εναλλαγή; Αν αλλάζουμε εικόνα ανά καρέ που
      δημιουργούμε (η προγραμματιστικά εύκολη λύση) δεν θα βλέπουμε τίποτα!
	  Μια αλλαγή που γίνεται 50-100 και παραπάνω φορές το δευτερόλεπτο είναι
      πρακτικά αόρατη. (Βλέπετε τις λάμπες στο σπίτι σας να αναβοσβήνουν;)
\item[-] Πως θα ρυθμίσουμε το συνολικό χρονικό διάστημα προβολής του εφέ; Θα
      πρέπει να ρυθμίσουμε είτε χρόνο είτε συνολικό αριθμό εναλλαγής των
	  εικόνων μέχρι να επιστρέψουμε στην αρχική, μοναχική εικόνα.
\end{itemize}

Αφού αποφασίσαμε ότι δεν μπορούμε να εναλλάσσουμε εικόνα ανά καρέ και δεν
μπορούμε να βασιστούμε στο framerate για το εφέ, υποπτευόμαστε ότι θα
υπάρχει κάποιος τρόπος να το χρονομετρήσουμε.  Ξέρουμε ήδη το γνωστό μας
clock το οποίο μας βοηθάει να κρατάμε σταθερή την ταχύτητα των
αντικειμένων μας ανεξάρτητα από το framerate. Μήπως θέλουμε και εδώ
κάτι αντίστοιχο;

Ευτυχώς για μας, το pygame υποστηρίζει τη χρήση timers και μάλιστα πολλαπλών.
Μπορούμε να ορίσουμε ένα timer με συγκεκριμένο χρόνο tick.
Σε κάθε tick του timer θα λαμβάνουμε ένα event -- αρκεί
να προσθέσουμε μερικές γραμμές στη διαχείριση events που ήδη έχουμε.

\section{Αλλαγές στις Βασικές Κλάσεις}

Έχοντας μια γενική ιδέα στο μυαλό μας, πριν προσπαθήσουμε να βάλουμε τον
timer πρέπει να ασχοληθούμε με πιο\ldots{} πεζά θέματα. Βλέπετε, όπως έχουμε
φτιάξει την κλάση {\tt Craft} δεν επιτρέπει παρά μόνο μια εικόνα για κάθε
αντικείμενο και ξαφνικά θέλουμε δύο. Ας μετατρέψουμε λίγο την κλάση {\tt Craft}:

\begin{minted}[bgcolor=bg, linenos, frame=lines, framesep=10pt]{python}
class Craft(object):
  def __init__ (self, imagefiles, coord):
    self.shape = [pygame.image.load(imagefile) for imagefile in imagefiles]
    self.ship_width = self.shape[0].get_width()
    self.ship_height = self.shape[0].get_height()
    self.rect = pygame.Rect(coord,(self.ship_width, self.ship_height))
    self.ship_midwidth = self.ship_width / 2
    self.firecolor=(255,0,0)
    self.firespeed = -800
    self.shotlength = 20

  def Show(self, surface,imageindex):
    surface.blit(self.shape[imageindex],(self.rect[0],self.rect[1]))
\end{minted}

Το {\tt self.shape} είναι πλέον λίστα και φορτώνουμε σε αυτό όλες τις εικόνες
   από τα ονόματα αρχείων που περιέχει το {\tt imagefiles} χρησιμοποιώντας το
   πολύ βολικό list comprehension
   (το έχουμε ξαναδεί, ψάξτε λίγο στον κύριο βρόχο!) Το {\tt imagefiles} μπορεί
   να είναι λίστα ή tuple.

Πρέπει όμως να δούμε και τις κλάσεις
που έχουν την {\tt Craft} ως γονική. Η {\tt Alien} βέβαια θα λαμβάνει μόνο μια εικόνα,
όμως αφού έχουμε μετατρέψει την γονική κλάση να χειρίζεται λίστα από
εικόνες τι θα κάνουμε;

\begin{minted}[bgcolor=bg, linenos, frame=lines, framesep=10pt]{python}
class Alien(Craft):
  def __init__(self, imagefile, coord, speed_x, speed_y):
    imagefiles = (imagefile,)
    super(Alien, self).__init__(imagefiles, coord)
\end{minted}

Πήραμε τo ένα όνομα αρχείου εικόνας που θα λάβει ο constructor της {\tt Alien}
   από το κύριο πρόγραμμα και το μετατρέψαμε σε tuple του\ldots{} ενός
   στοιχείου για να το δώσουμε στον γονικό constructor της {\tt Craft}! Η αστεία
   αυτή μετατροπή έγινε με την εντολή:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
    imagefiles = (imagefile,)
\end{minted}

Το κόμμα δείχνει ότι δημιουργούμε tuple με ένα μόνο στοιχείο. Δεν θα
   μπορούσαμε να χρησιμοποιήσουμε μόνο την παρένθεση γιατί η Python δεν θα
   ήξερε αν προσπαθούμε να φτιάξουμε tuple ή παράσταση (όλα τα έχουν
   προβλέψει πια αυτοί οι Python developers!)

Πρέπει να φτιάξουμε και μια συνάρτηση {\tt Show} για το {\tt Alien} class, το οποίο μέχρι τώρα χρησιμοποιούσε αυτούσιο την αντίστοιχη του {\tt Craft} class:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  def Show(self, surface):
    imageindex = 0
    super(Alien,self).Show(surface,imageindex)
\end{minted}

Τέλειο! Αφού το {\tt Alien} έχει πάντα σταθερή εικόνα, το {\tt imageindex} θα είναι πάντα μηδέν και θα δείχνει τη μια και μοναδική εικόνα που έχουμε δώσει. Ενώ
   στο δικό μας διαστημόπλοιο, μπορούμε να αλλάζουμε το {\tt imageindex} κατά
   βούληση αλλάζοντας του έτσι και τη μορφή.

Πάμε να δούμε τις αλλαγές στο κύριο πρόγραμμα. Έξω από το βρόχο ορίζουμε τις μεταβλητές {\tt imageindex} και {\tt flashcount}:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  imageindex = 0
  flashcount = 0
\end{minted}

Η δημιουργία του {\tt SpaceShip} αλλάζει ελαφρά αφού πλέον θα του δώσουμε ένα
   tuple με δύο εικόνες:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  shipimages = ('spaceship2.png', 'spaceship3.png')
  SpaceShip = SpaceCraft(shipimages,spaceship_pos, spaceship_low, spaceship_high,laser)
\end{minted}

Τέλος, το μόνο άλλο που αλλάζει είναι η κλήση της {\tt Show} για το διαστημόπλοιο μας μέσα στον κύριο βρόχο:

\begin{minted}[bgcolor=bg,  frame=lines, framesep=10pt]{python}
    SpaceShip.Show(screen,imageindex)
\end{minted}

\section{Προσθήκη του Timer}

To παιχνίδι μας πρέπει τώρα να λειτουργεί όπως πριν και μένει μόνο ο
   timer για την εναλλαγή των εικόνων. Ώρα να τον εγκαινιάσουμε:

\begin{minted}[bgcolor=bg, linenos, frame=lines, framesep=10pt]{python}
        if SpaceShip.rect.collidepoint(theshot.GetXY()) and not GameOver:
          destroyed.play()
          pygame.time.set_timer(USEREVENT+1,25)
          shield.Decrease(25)
\end{minted}

Όταν χτυπηθούμε, ξεκινά ένας timer ο οποίος θα στέλνει το event {\tt USEREVENT+1}   ανά 25 χιλιοστά του δευτερολέπτου.  Το {\tt USEREVENT} περιέχεται και αυτό στο {\tt pygame.locals} και όπως φαντάζεστε είναι η αρχή μιας σειράς αριθμών που
   δεν χρησιμοποιούνται κάπου αλλού και μπορούμε να τα χρησιμοποιήσουμε για
   τα δικά μας συμβάντα (μπορούμε να έχουμε {\tt USEREVENT+1, USEREVENT+2} κλπ).

Το μόνο που μένει τώρα είναι να αναβοσβήσουμε το διαστημόπλοιο μας δέκα
   φορές και μετά να απενεργοποιήσουμε το timer. Οι γραμμές προστίθενται
   στο βρόχο {\tt for} διαχείρισης των συμβάντων:

\begin{minted}[bgcolor=bg, linenos, frame=lines, framesep=10pt]{python}
      if event.type == USEREVENT+1:
        if flashcount < 10:
          flashcount += 1
          if imageindex == 1:
            imageindex = 0
          else:
            imageindex = 1
        else:
          imageindex = 0
          flashcount = 0
          pygame.time.set_timer(USEREVENT+1,0)
\end{minted}

Κάθε φορά που λαμβάνουμε ένα event τύπου {\tt USEREVENT+1}, ελέγχουμε το
   {\tt flashcount}. Αν δεν έχει φτάσει ακόμα την τιμή 10, αλλάζουμε το {\tt imageindex} από 0 σε 1 ή αντίστροφα. Όταν το {\tt flashcount} γίνει 10, επιστρέφουμε στην κανονική εικόνα, μηδενίζουμε το {\tt flashcount} και φυσικά απενεργοποιούμε το timer θέτοντας του μηδέν στο χρόνο tick. Πανεύκολο!

\section{Επεκτείνοντας το Παιχνίδι: Μερικές Βασικές Ιδέες}

Ο κώδικας είναι το καλύτερο παιχνίδι! Αν το πιστεύετε και εσείς, ορίστε
   μερικές ιδέες για να επεκτείνετε το Pygame Invaders:

\begin{itemize}
  \item Κάντε μερικούς εξωγήινους να ρίχνουν δωράκια όταν τους σκοτώνετε:
      Power ups, αύξηση ασπίδας, πιο γρήγορο Laser για το σκάφος σας.
      Πάρτε ιδέες από παιχνίδια όπως το Arkanoid.

  \item Κάντε τη δυσκολία του παιχνιδιού να αλλάζει όσο αυξάνονται τα κύματα
      των εξωγήινων. Μπορεί να ρίχνουν πιο συχνά, να κινούνται πιο γρήγορα
      ή να έχουν κάποιο\ldots{} σχέδιο να σας καταστρέψουν αντί να κάνουν bounce
      αριστερά -- δεξιά.

  \item Προσθέστε πίστες: Μετά από μερικά κύματα θα μπορούσατε να κάνετε ένα
      γρήγορο warp (κινούμενο background έχετε!) και να βρίσκεστε κάπου
      με διαφορετικούς εξωγήινους.

  \item Βάλτε μια έξτρα πίστα με μετεωρίτες αντί για εξωγήινους. Δείτε το
      Parsec του TI-99/4A στο \url{http://www.youtube.com/watch?v=uCSQd0eJKQQ}.

  \item Στα εξελιγμένα διαστημικά παιχνίδια, στο τέλος εμφανίζεται ο Μεγάλος
      Κακός\texttrademark. Φτιάξτε μια πίστα με τον τεράστιο εξωγήινο που θα πρέπει
      να του ρίξετε Laser, Phasers και το περίσσευμα της προχθεσινής πίτσας
      για να πεθάνει!

  \item Προσθέστε cheats για να παίζετε χωρίς να χάνετε -- σε αντίθεση με τους
      φίλους σας (έπρεπε να το έχετε κάνει ήδη).

  \item Στο διαστημόπλοιο μας έχουμε ήδη και κίνηση πάνω -- κάτω εκτός από
      αριστερά -- δεξιά. Δεν ανιχνεύονται όμως συγκρούσεις μεταξύ του
      σκάφους μας και των εξωγήινων. Φτιάξτε το!
\end{itemize}

Θα χαρούμε πολύ να δούμε παραλλαγές και βελτιώσεις στο παιχνίδι μας -- και
   γιατί όχι και τα δικά σας παιχνίδια! Αν θέλετε μάλιστα μπορούμε να τα
   δημοσιεύσουμε στο \url{http://pygamegr.wordpress.com}
   από όπου μπορείτε να κατεβάσετε και τον πλήρη και τελικό (για μας!)
   κώδικα του Pygame Invaders.

To listing θα το βρείτε επίσης στο παράρτημα, σελ. \pageref{listing:pygame-invaders}. Μπορείτε επίσης να κατεβάσετε το πλήρες παιχνίδι από εδώ: \url{http://www.freebsdworld.gr/files/pygame-invaders.zip}
