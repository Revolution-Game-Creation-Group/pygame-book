\chapter{Συναρτήσεις -- Ενσωματωμένες και Δικές μας!}
\label{chap:functions-intro}
%
\section{Εισαγωγή}
%
Είμαστε σίγουροι ότι το adventure που δημοσιεύσαμε στο προηγούμενο κεφάλαιο 
σας έβαλε σε σκέψεις. Όχι γιατί ήταν δύσκολο στο\ldots{} gameplay, αλλά γιατί
είχε μεγάλο ενδιαφέρον από προγραμματιστικής  άποψης.  Αν και όλη η βασική
λογική (ο αλγόριθμος αν θέλετε) παρουσιάστηκε στο προηγούμενο κεφάλαιο,
αφήσαμε κάποια τμήματα που θα εξετάσουμε εδώ. Για να τα εξηγήσουμε θα
πρέπει να μιλήσουμε για ένα πολύ σημαντικό στοιχείο της python (και των
περισσότερων γλωσσών): Τις συναρτήσεις!
%
\section{Συναρτήσεις στην Python}
%
Αν η λέξη συνάρτηση σας θυμίζει κάτι από μαθηματικά, δεν έχετε πολύ
άδικο. Βέβαια στις περισσότερες γλώσσες η έννοια της συνάρτησης είναι
θα λέγαμε πιο χαλαρή σε σχέση με τα μαθηματικά. Στα μαθηματικά για
παράδειγμα, σκεφτόμαστε τη συνάρτηση σαν μια σχέση στην οποία δίνουμε
κάποια δεδομένα (ένα αριθμό) και μας δίνει ένα αποτέλεσμα. Αν θέλουμε
να είμαστε ακριβείς, μια συνάρτηση στα μαθηματικά δεν μπορεί να δίνει
διαφορετικές τιμές σαν αποτέλεσμα αν δίνουμε πάντοτε την ίδια τιμή στην
είσοδο.

Σε πολλές γλώσσες προγραμματισμού, μπορούμε να ορίσουμε συναρτήσεις που
να συμπεριφέρονται με ακριβώς τον ίδιο τρόπο όπως στα μαθηματικά. Για
την ακρίβεια, η python --- όπως και οι περισσότερες γλώσσες --- διαθέτει
ήδη μια μεγάλη γκάμα από συναρτήσεις που έχουν έρθει κατευθείαν από
τα μαθηματικά.  Πάρτε για παράδειγμα την τετραγωνική ρίζα:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
import math
x = math.sqrt(2)
print x
\end{minted}

Ο παραπάνω κώδικας θα μας τυπώσει την τετραγωνική ρίζα του 2. Ήδη από
το πρώτο μας παιχνίδι, έχετε δει πως καλούμε μια συνάρτηση και πως
αποθηκεύουμε το αποτέλεσμα. Θυμηθείτε τη γραμμή:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
number = random.randint(1,50)
\end{minted}

Προφανώς λοιπόν μια συνάρτηση καλείται με τα ορίσματα
μέσα σε παρένθεση και το αποτέλεσμα το λαμβάνουμε στη μεταβλητή που
έχουμε πριν το ίσον.  Για να χρησιμοποιήσουμε συγκεκριμένες συναρτήσεις,
πρέπει πρώτα να συμπεριλάβουμε τη βιβλιοθήκη που τις περιέχει όπως
φαίνεται π.χ.  από το {\tt import math} παραπάνω.

Για να πάρετε μια ιδέα τώρα το πως μια συνάρτηση στην python μπορεί να
διαφοροποιείται από μια καθαρά μαθηματική συνάρτηση, θυμηθείτε την {\tt range}
που είχαμε δει στην αρχή του προηγούμενου κεφαλαίου:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
>>> x = range(1,10)
>>> print x

[1, 2, 3, 4, 5, 6, 7, 8, 9]
\end{minted}

Βλέπετε εδώ ότι η python δεν επιστρέφει ένα απλό αριθμό --- κάτι που
αναμένουμε συνήθως από μια μαθηματική συνάρτηση --- αλλά μια ολόκληρη
λίστα.

Βέβαια ακόμα πιο ενδιαφέρον είναι να αρχίσουμε να δημιουργούμε τις
δικές μας συναρτήσεις!
%
\section{Δημιουργία Συνάρτησης}
%
Για ποιο λόγο να θέλουμε να κάνουμε κάτι τέτοιο; Για να δείτε πως
δημιουργείται η ανάγκη για τη δημιουργία μιας συνάρτησης, ας πάρουμε
την τετραγωνική ρίζα που είδαμε παραπάνω. Φανταστείτε λοιπόν ότι η
γλώσσα που χρησιμοποιούσατε δεν είχε κανένα τρόπο να υπολογίζει
τετραγωνικές ρίζες.  Εσείς όμως, ως καταπληκτικός και wow
προγραμματιστής, φτιάξατε ένα κομμάτι κώδικα που το κάνει. Και τώρα;

Θα μπορούσατε βέβαια κάθε φορά που στο κύριο πρόγραμμα σας
χρειαζόσασταν μια τετραγωνική ρίζα, να κάνατε αντιγραφή -- επικόλληση
εκείνο το ίδιο κομμάτι κώδικα (δεν είναι τυχαίο που από τότε που
εφευρέθηκε η αντιγραφή -- επικόλληση χάθηκαν οι προγραμματιστές).
Σύντομα όλη η ουσία του κανονικού προγράμματος σας θα χάνονταν μέσα
στις\ldots{} επικολλήσεις της τετραγωνικής ρίζας. Θα ήταν προφανώς
προτιμότερο να δίνατε με κάποιο τρόπο ένα όνομα σε αυτό το κομμάτι
κώδικα και να το καλείτε κάθε φορά που θέλετε να κάνετε τον υπολογισμό.
Με λίγα λόγια:

{\bf Χρειάζεστε μια συνάρτηση!}

Είναι εύκολο να καταλάβετε από τα παραπάνω ότι:
%
\begin{itemize}
  \item Μια συνάρτηση τη χρησιμοποιούμε όταν χρειάζεται να εκτελέσουμε
      το ίδιο κομμάτι κώδικα πολλές φορές (και με άλλες ενδεχομένως
      τιμές)
  \item Μια καλογραμμένη συνάρτηση κάνει μια συγκεκριμένη εργασία και
      μπορεί να μας φανεί χρήσιμη σε πολλά προγράμματα
  \item Η σωστή χρήση συναρτήσεων κάνει το πρόγραμμα μας
      {\em δομημένο} και μπορούμε πολύ εύκολα να ακολουθήσουμε
      τη ροή και τη λογική του.
\end{itemize}
%
Και κάτι ακόμα που μάλλον υποπτεύεστε:
%
\begin{itemize}
  \item Οι συναρτήσεις στην python {\bf δεν περιορίζονται} στον αυστηρό ορισμό
      της μαθηματικής συνάρτησης.
\end{itemize}
%
Τι σημαίνει αυτό; Όπως είδατε, μπορεί να επιστρέφουν αντί για ένα
αριθμό, μια λίστα. Ή ίσως μια αλφαριθμητική τιμή (ένα όνομα, κομμάτι
κειμένου ή {\em string} όπως το λέμε συνήθως).  Αλλά μπορεί να μην
επιστρέφουν και\ldots{} τίποτα! Ναι, καλά διαβάσατε: τίποτα! Και όχι, δεν
έχουμε χάσει το μυαλό μας ακόμα (όχι εντελώς δηλαδή).  Θα μου πείτε, τι
μπορεί να χρησιμεύσει μια συνάρτηση που δεν επιστρέφει τίποτα;

Μα είπαμε ότι δεν πρόκειται για αυστηρό ορισμό μαθηματικής συνάρτησης.
Φανταστείτε για παράδειγμα μια συνάρτηση που τυπώνει κάτι στην οθόνη.
Για να μην είναι τελείως απλοϊκή, φανταστείτε ότι την έχουμε φτιάξει
ώστε να της δίνουμε ως όρισμα το κείμενο που θέλουμε να τυπώσει και
η συνάρτηση να το κεντράρει στα αριστερά -- δεξιά περιθώρια της οθόνης.
Τι επιστρέφει αυτή η συνάρτηση; Τίποτα. Κάνει μια δουλειά (τυπώνει το
μήνυμα) αλλά δεν επιστρέφει κάποια τιμή στο κύριο πρόγραμμα που να
προκύπτει από κάποιο υπολογισμό και να έχει κάποια χρησιμότητα.

Σε κάποιες γλώσσες προγραμματισμού, υπάρχει ή έννοια της {\em διαδικασίας
ή procedure} για την περίπτωση που δεν υπάρχει
επιστρεφόμενη τιμή.  Στην python ωστόσο, χρησιμοποιούμε συναρτήσεις
και για τις δύο περιπτώσεις.

Παρακάτω είναι ο κώδικας και η αντίστοιχη δοκιμή:

\begin{minted}[bgcolor=bg, frame=lines, linenos, framesep=10pt]{python}
def centerText(thetext):
  linelength = 80
  textlength = len(thetext)
  spaces = (linelength - textlength)/2
  print spaces*" "+thetext
  return

centerText("Hello there!")
\end{minted}

Στο παραπάνω θεωρούμε ότι το μέγεθος γραμμής της οθόνης είναι 80
χαρακτήρες (ένα τυπικό τερματικό).  Η συνάρτηση τυπώνει το μήνυμα μας
με τον απαραίτητο αριθμό κενών από μπροστά ώστε να κεντράρεται.
Όταν την καλούμε, το κείμενο ``Hello there!'' αντιγράφεται ουσιαστικά μέσα
στη μεταβλητή {\tt thetext} της συνάρτησης. Θα μπορούσαμε επίσης
να την καλέσουμε και έτσι:

\begin{minted}[bgcolor=bg, frame=lines,  framesep=10pt]{python}
mytext = "I really love Python programming"
centerText(mytext)
\end{minted}

Τι γίνεται σε αυτή την περίπτωση; Όπως φαντάζεστε, η τιμή που περιέχει
η μεταβλητή {\tt mytext} αντιγράφεται στην μεταβλητή {\tt thetext} της συνάρτησης
την ώρα που την καλούμε. Σημειώστε εδώ ότι η μεταβλητή {\tt thetext}
της συνάρτησης είναι {\em τοπική} για τη συνάρτηση και δεν
είναι γνωστή έξω από αυτή. Αν έχετε μια μεταβλητή {\tt thetext} στη συνάρτηση
σας και μια άλλη {\tt thetext} έξω από αυτή, αυτές οι δύο δεν σχετίζονται και
δεν μπερδεύονται μεταξύ τους! Για να πάμε και ένα βήμα παραπέρα, όλες
οι μεταβλητές που ορίζουμε μέσα στη συνάρτηση είναι {\em τοπικές} για αυτή
και υπάρχουν και έχουν νόημα μόνο όσο η συνάρτηση εκτελείται.

Μια ερώτηση που ίσως έχετε είναι τι γίνεται σε περίπτωση που κάνετε κάτι
μέσα στη συνάρτηση και πειράξετε το ίδιο το όρισμα. Π.χ. τι θα γίνει
αν αλλάξετε τη μεταβλητή {\tt thetext}. Πιστεύετε θα γίνει και η μεταφορά
αντίστροφα (από τη συνάρτηση στο κύριο πρόγραμμα, στη {\tt mytext});

Η απάντηση είναι {\bf όχι}. Όπως είπαμε, κατά την κλήση της
συνάρτησης, αντιγράφεται η τιμή της μεταβλητής {\tt mytext} στην μεταβλητή
{\tt thetext}. Αυτή είναι και η μόνη αλληλεπίδραση που υπάρχει μεταξύ τους
και είναι μόνο προς τη μια κατεύθυνση. Αυτό το είδος περάσματος τιμών
μεταξύ του κύριου προγράμματος και μιας συνάρτησης ονομάζεται
{\em κλήση με τιμή ή call by value} αν προτιμάτε. Σε άλλες
γλώσσες είναι πιθανή και η {\em κλήση κατά αναφορά ή
call by reference} (που φαντάζεστε τι κάνει) αλλά στην python
έχουμε άλλα\ldots{} κόλπα στο τσεπάκι μας για αντίστοιχα τρικ.

Και πως θα γράφαμε μια συνάρτηση που πράγματι να επιστρέφει μια τιμή
στο κύριο πρόγραμμα:

\begin{minted}[bgcolor=bg, frame=lines, linenos, framesep=10pt]{python}
def cube(thenumber):
  result = thenumber ** 3
  return result

x = 3
y = cube(x)
print y
print cube(3)
print cube(y)
\end{minted}

Πιστεύουμε είναι προφανές το πως λειτουργεί! Στο κύριο (θεός να το κάνει)
πρόγραμμα σας δείχνουμε και διάφορους τρόπους κλήσης της συνάρτησης.

Προφανώς θα μπορούσε και η συνάρτηση μας να γραφεί πολύ πιο απλά,
επί της ουσίας σε μια γραμμή:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
def cube(thenumber):
  return thenumber**3
\end{minted}

Και με αυτό το\ldots{} crash course στις συναρτήσεις, είμαστε πιστεύουμε
έτοιμοι να δούμε πως δουλεύει η συνάρτηση {\tt getInput} που έχουμε
στο καταπληκτικό μας Adventure!
%
\section{Η Συνάρτηση getInput στο Adventure}
%
Ας τη δούμε συνολικά και να την ερμηνεύσουμε:

\begin{minted}[bgcolor=bg, frame=lines, linenos, framesep=10pt]{python}
def getInput(moves,room):
  directions = ["Βόρεια","Νότια","Ανατολικά","Δυτικά"]
  destinations = moves[room]
  possiblemoves = []
  index = 0
  print "Έξοδοι:",
  for i in destinations:
    if i!=-1:
      print directions[index],
      possiblemoves.append(directions[index])
    index +=1
  print "\n"
  userinput=""
  while userinput not in possiblemoves:
    userinput=raw_input("Που θες να πας; ")
  return directions.index(userinput)
\end{minted}

Η συνάρτηση έχει δύο ορίσματα, τα {\tt moves} και {\tt room}. Θυμηθείτε ότι το {\tt moves}
περιέχει τις κινήσεις από το ένα δωμάτιο στο άλλο και το {\tt room} είναι ο
αριθμός του τρέχοντος δωματίου. Μη ξεχνάτε ότι τα ονόματα των μεταβλητών
αυτών θα μπορούσαν να είναι διαφορετικά μέσα στη συνάρτηση και δεν υπάρχει
μπέρδεμα με το κύριο πρόγραμμα!

Μέσα στην συνάρτηση ορίζεται μια λίστα {\tt directions} που περιέχει
τα ονόματα των κατευθύνσεων. Προσέξτε ότι την έχουμε φτιάξει με τέτοιο
τρόπο ώστε ο δείκτης του κάθε στοιχείου να αντιστοιχεί στην κωδικοποίηση
που έχουμε κάνει, δηλ. Βόρεια = 0, Νότια =1 κλπ.

Η πρώτη δουλειά της συνάρτησης είναι να βρει την λίστα των προορισμών
από το συγκεκριμένο δωμάτιο:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  destinations = moves [room]
\end{minted}

Αμέσως παρακάτω, ορίζουμε μια κενή λίστα {\tt possiblemoves}, τυπώνουμε
ένα μήνυμα στο χρήστη και εισερχόμαστε στο κύριο βρόχο {\tt for}:

\begin{minted}[bgcolor=bg, frame=lines, linenos, framesep=10pt]{python}
  index = 0
  print "Έξοδοι:",
  for i in destinations:
    if i!=-1:
      print directions[index],
      possiblemoves.append(directions[index])
    index +=1
\end{minted}

Ο βρόχος διατρέχει ένα -- ένα τα στοιχεία της λίστας {\tt destinations}. Αν για
παράδειγμα, βρισκόμασταν στο δωμάτιο 7, το {\tt i} θα διατρέξει τους
αριθμούς:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
[6, 9, 8, -1]
\end{minted}

Ας πάρουμε λοιπόν την πρώτη φορά. Το {\tt i} θα έχει την τιμή 6. Έχουμε τη
σύγκριση:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
    if i!=-1:
      print directions[index],
      possiblemoves.append(directions[index])
\end{minted}

Προφανώς το {\tt i} δεν είναι -1, οπότε εκτελείται η εντολή:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
      print directions[index]
\end{minted}

και καθώς το {\tt index} έχει την τιμή 0 (η αρχική του), το παραπάνω θα
   τυπώσει:

\begin{verbatim}
Βόρεια
\end{verbatim}

(Το κόμμα στην άκρη της {\tt print} εμποδίζει την αλλαγή γραμμής.) Ταυτόχρονα,
 στη λίστα {\tt possiblemoves} προστίθεται η τιμή που τυπώθηκε παραπάνω:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
      possiblemoves.append(directions[index])
\end{minted}

Η {\tt append} είναι μια μέθοδος που εφαρμόζεται σε λίστες για να
προσθέσουμε ένα στοιχείο στο τέλος. Μετά την πρώτη εκτέλεση του βρόχου,
η λίστα {\tt possiblemoves} θα περιέχει την πρώτη της τιμή:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
[ "Βόρεια" ]
\end{minted}

Για τις μεθόδους θα μιλήσουμε αναλυτικότερα σε επόμενη ενότητα, αλλά
πιστεύουμε κατανοείτε τι γίνεται. Σκεφτείτε τώρα ότι το ίδιο ακριβώς
γίνεται και για τις άλλες τιμές που θα πάρει το {\tt i}, ώστε στο τέλος η
λίστα {\tt possiblemoves} να περιέχει:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
[ "Βόρεια", "Νότια", "Ανατολικά" ]
\end{minted}

Και ναι δεν θα περιέχει τη λέξη ``Δυτικά'' καθώς η τελευταία τιμή που
παίρνει το {\tt i} είναι -1.  Προσέξτε ότι σε κάθε κύκλο της {\tt for} αυξάνουμε την
τιμή του {\tt index} κρατώντας σε συγχρονισμό το δείκτη με το
αντίστοιχο στοιχείο της λίστας {\tt destinations}.

Το υπόλοιπο κομμάτι είναι απλό. Με το τέλος του βρόχου, αλλάζουμε γραμμή
τυπώνοντας τον ειδικό χαρακτήρα αλλαγής γραμμής:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  print "\n"
\end{minted}

Τέλος, ορίζουμε μια μεταβλητή {\tt userinput} στην οποία θα
αποθηκεύσουμε την είσοδο του χρήστη. Αρχικά είναι κενή, και εισερχόμαστε
στο βρόχο {\tt while}:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  userinput=""
  while userinput not in possiblemoves:
    userinput=raw_input("Που θες να πας; ")
\end{minted}

Όπως καταλαβαίνετε ο βρόχος ρωτάει και ξαναρωτάει το χρήστη για την
κίνηση του μέχρι να λάβει μια έγκυρη απάντηση, μια απάντηση δηλ. που
να βρίσκεται στη λίστα {\tt possiblemoves} που δημιουργήσαμε
προηγουμένως. Με τη λήψη έγκυρης απάντησης, η συνάρτηση επιστρέφει την παρακάτω\ldots{}
κρυπτική τιμή:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
  return directions.index(userinput)
\end{minted}

Και δεν είναι στην πραγματικότητα καθόλου κρυπτική: Αν ο χρήστης έδωσε
``Νότια'', η μέθοδος {\tt index} επιστρέφει το δείκτη, τη θέση δηλαδή,
του στοιχείου της λίστας {\tt directions} στην οποία βρίσκεται η τιμή
   ``Νότια''. Δηλ. το 1.

Για να το καταλάβετε, το παρακάτω:

\begin{minted}[bgcolor=bg, frame=lines, framesep=10pt]{python}
print directions.index("Ανατολικά")
\end{minted}

Θα τύπωνε τον αριθμό 2. Ο αριθμός αυτός επιστρέφεται στο κύριο πρόγραμμα
ως αποτέλεσμα της συνάρτησης. Και όπως θα παρατηρήσατε, έχουμε φτιάξει
μια συνάρτηση που τυπώνει μηνύματα, δέχεται και επικυρώνει την είσοδο
από το χρήστη και τελικά επιστρέφει και την τιμή έτοιμη για χρήση στο
κύριο πρόγραμμα. Όπως καταλαβαίνετε μια συνάρτηση στην python σίγουρα
δεν περιορίζεται στην κλασική μαθηματική έννοια της συνάρτησης!

Προφανώς ο παραπάνω τρόπος δεν είναι επίσης ο μοναδικός που θα μπορούσε
να χρησιμοποιηθεί για να γραφεί η {\tt getInput}. Θα μπορούσαμε επίσης να
χρησιμοποιήσουμε τα {\em λεξικά ή dictionaries} της python.
Επίσης θα μπορούσαμε να χωρίσουμε τη λειτουργία
της {\tt getInput} σε περισσότερες συναρτήσεις ή ακόμα και να
μεταφέρουμε κάποια κομμάτια της στο κύριο πρόγραμμα. Θα μπορούσαμε π.χ.
να φτιάξουμε μια {\tt getMoves} η οποία να επιστρέφει τη λίστα
{\tt possiblemoves} και η διαχείριση της εισόδου να γίνεται στο κύριο
πρόγραμμα. Και τώρα ξέρετε\texttrademark{} την άσκηση σας μέχρι το επόμενο
κεφάλαιο! Καλό θα ήταν επίσης να προσθέσετε την {\tt centerText} που
φτιάξαμε ώστε τα μηνύματα του προγράμματος να κεντράρονται.

Πριν προχωρήσετε στο επόμενο κεφάλαιο, διαβάστε και πειραματιστείτε. Μη ξεχνάτε, ο προγραμματισμός είναι μια συνεχής ασχολία. Καλό ξεκόλλημα!
